<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WASM Demo</title>
  </head>
  <body>
    <h1>Rust â†’ WASM (no bundler)</h1>
    <div id="controls" style="margin:8px 0; font: 14px/1.4 system-ui, sans-serif; color:#ddd">
      <label>Points: <span id="pointsVal">200</span>
        <input id="points" type="range" min="0" max="1000" step="1" value="200" />
      </label>
      <label style="margin-left:12px;">Capacity: <span id="capVal">8</span>
        <input id="capacity" type="range" min="1" max="64" step="1" value="8" />
      </label>
      <label style="margin-left:12px;">Rotation: <span id="speedVal">0.01</span>
        <input id="speed" type="range" min="-0.1" max="0.1" step="0.001" value="0.01" />
      </label>
      <label style="margin-left:12px;"><input id="showLines" type="checkbox" checked /> Lines</label>
      <label style="margin-left:6px;"><input id="showPoints" type="checkbox" checked /> Points</label>
      <button id="randomize" style="margin-left:12px;">Randomize</button>
      <button id="apply" style="margin-left:6px;">Apply</button>
    </div>
    <canvas id="gl" width="800" height="600" style="border:1px solid #444"></canvas>
    <script type="module">
      import init, { Octree } from './wasm_lib.js';

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(shader) || 'shader compile failed');
        }
        return shader;
      }

      function createProgram(gl, vsSource, fsSource) {
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(program) || 'program link failed');
        }
        return program;
      }

      function perspective(out, fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
        out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
        out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
        out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
      }

      function lookAt(out, eye, center, up) {
        const ex = eye[0], ey = eye[1], ez = eye[2];
        const cx = center[0], cy = center[1], cz = center[2];
        let zx = ex - cx, zy = ey - cy, zz = ez - cz;
        let len = Math.hypot(zx, zy, zz); zx /= len; zy /= len; zz /= len;
        let xx = up[1] * zz - up[2] * zy;
        let xy = up[2] * zx - up[0] * zz;
        let xz = up[0] * zy - up[1] * zx;
        len = Math.hypot(xx, xy, xz); xx /= len; xy /= len; xz /= len;
        let yx = zy * xz - zz * xy;
        let yy = zz * xx - zx * xz;
        let yz = zx * xy - zy * xx;
        out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
        out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
        out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
        out[12] = -(xx * ex + xy * ey + xz * ez);
        out[13] = -(yx * ex + yy * ey + yz * ez);
        out[14] = -(zx * ex + zy * ey + zz * ez);
        out[15] = 1;
      }

      function multiply(out, a, b) {
        const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
        out[0] = a00*b00 + a10*b01 + a20*b02 + a30*b03;
        out[1] = a01*b00 + a11*b01 + a21*b02 + a31*b03;
        out[2] = a02*b00 + a12*b01 + a22*b02 + a32*b03;
        out[3] = a03*b00 + a13*b01 + a23*b02 + a33*b03;
        out[4] = a00*b10 + a10*b11 + a20*b12 + a30*b13;
        out[5] = a01*b10 + a11*b11 + a21*b12 + a31*b13;
        out[6] = a02*b10 + a12*b11 + a22*b12 + a32*b13;
        out[7] = a03*b10 + a13*b11 + a23*b12 + a33*b13;
        out[8] = a00*b20 + a10*b21 + a20*b22 + a30*b23;
        out[9] = a01*b20 + a11*b21 + a21*b22 + a31*b23;
        out[10] = a02*b20 + a12*b21 + a22*b22 + a32*b23;
        out[11] = a03*b20 + a13*b21 + a23*b22 + a33*b23;
        out[12] = a00*b30 + a10*b31 + a20*b32 + a30*b33;
        out[13] = a01*b30 + a11*b31 + a21*b32 + a31*b33;
        out[14] = a02*b30 + a12*b31 + a22*b32 + a32*b33;
        out[15] = a03*b30 + a13*b31 + a23*b32 + a33*b33;
      }

      function aabbLinesFromArray(aabbs) {
        const lines = [];
        for (let i = 0; i < aabbs.length; i += 6) {
          const minx = aabbs[i+0], miny = aabbs[i+1], minz = aabbs[i+2];
          const maxx = aabbs[i+3], maxy = aabbs[i+4], maxz = aabbs[i+5];
          const c = [
            [minx, miny, minz], [maxx, miny, minz], [maxx, maxy, minz], [minx, maxy, minz],
            [minx, miny, maxz], [maxx, miny, maxz], [maxx, maxy, maxz], [minx, maxy, maxz],
          ];
          const edges = [
            [0,1],[1,2],[2,3],[3,0],
            [4,5],[5,6],[6,7],[7,4],
            [0,4],[1,5],[2,6],[3,7],
          ];
          for (const [a,b] of edges) {
            lines.push(c[a][0], c[a][1], c[a][2]);
            lines.push(c[b][0], c[b][1], c[b][2]);
          }
        }
        return new Float32Array(lines);
      }

      (async () => {
        await init();
        const canvas = document.getElementById('gl');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
          console.error('WebGL not supported');
          return;
        }

        const vs = `
          attribute vec3 a_position;
          uniform mat4 u_mvp;
          void main() {
            gl_Position = u_mvp * vec4(a_position, 1.0);
            gl_PointSize = 4.0;
          }
        `;
        const fs = `
          precision mediump float;
          uniform vec3 u_color;
          void main() { gl_FragColor = vec4(u_color, 1.0); }
        `;
        const program = createProgram(gl, vs, fs);
        const aPos = gl.getAttribLocation(program, 'a_position');
        const uMvp = gl.getUniformLocation(program, 'u_mvp');
        const uColor = gl.getUniformLocation(program, 'u_color');

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.06, 0.06, 0.08, 1);

        let settings = { numPoints: 200, capacity: 8, rotSpeed: 0.01, showLines: true, showPoints: true };
        let pointsData = new Float32Array(settings.numPoints * 3);
        function randomizePoints() {
          pointsData = new Float32Array(settings.numPoints * 3);
          for (let i = 0; i < settings.numPoints; i++) {
            pointsData[i*3+0] = Math.random();
            pointsData[i*3+1] = Math.random();
            pointsData[i*3+2] = Math.random();
          }
        }
        randomizePoints();

        let tree = new Octree(0, 0, 0, 1, 1, 1, settings.capacity);
        function rebuildTree() {
          tree = new Octree(0, 0, 0, 1, 1, 1, settings.capacity);
          for (let i = 0; i < settings.numPoints; i++) {
            tree.insert(pointsData[i*3+0], pointsData[i*3+1], pointsData[i*3+2], i);
          }
          updateBuffers();
        }

        let lineVerts = new Float32Array(0);
        let lineVbo = gl.createBuffer();
        let pointVbo = gl.createBuffer();
        let pointCount = 0;
        function updateBuffers() {
          const aabbs = tree.all_node_aabbs();
          const pts = tree.all_points();
          lineVerts = aabbLinesFromArray(aabbs);
          pointCount = pts.length / 3;
          gl.bindBuffer(gl.ARRAY_BUFFER, lineVbo);
          gl.bufferData(gl.ARRAY_BUFFER, lineVerts, gl.STATIC_DRAW);
          gl.bindBuffer(gl.ARRAY_BUFFER, pointVbo);
          gl.bufferData(gl.ARRAY_BUFFER, pts, gl.STATIC_DRAW);
        }

        updateBuffers();

        const proj = new Float32Array(16);
        const view = new Float32Array(16);
        const mvp = new Float32Array(16);
        let angle = 0;

        function render() {
          angle += settings.rotSpeed;
          const radius = 2.0;
          const cx = 0.5, cy = 0.5, cz = 0.5;
          const eye = [cx + Math.cos(angle) * radius, cy + radius * 0.4, cz + Math.sin(angle) * radius];
          const center = [cx, cy, cz];
          const up = [0, 1, 0];

          perspective(proj, Math.PI / 4, canvas.width / canvas.height, 0.01, 100);
          lookAt(view, eye, center, up);
          // Compute MVP as P * V (projection first, then view)
          multiply(mvp, proj, view);

          gl.viewport(0, 0, canvas.width, canvas.height);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.useProgram(program);
          gl.uniformMatrix4fv(uMvp, false, mvp);

          gl.enableVertexAttribArray(aPos);
          if (settings.showLines && lineVerts.length) {
            gl.bindBuffer(gl.ARRAY_BUFFER, lineVbo);
            gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
            // Bright green wireframe. Note: many browsers clamp lineWidth to 1.
            gl.lineWidth(6);
            gl.uniform3f(uColor, 0.0, 1.0, 0.0);
            gl.drawArrays(gl.LINES, 0, lineVerts.length / 3);
          }

          if (settings.showPoints && pointCount) {
            gl.bindBuffer(gl.ARRAY_BUFFER, pointVbo);
            gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
            gl.uniform3f(uColor, 1.0, 0.2, 0.2);
            gl.drawArrays(gl.POINTS, 0, pointCount);
          }

          requestAnimationFrame(render);
        }
        render();

        // Controls wiring
        const elPoints = document.getElementById('points');
        const elPointsVal = document.getElementById('pointsVal');
        const elCap = document.getElementById('capacity');
        const elCapVal = document.getElementById('capVal');
        const elSpeed = document.getElementById('speed');
        const elSpeedVal = document.getElementById('speedVal');
        const elShowLines = document.getElementById('showLines');
        const elShowPoints = document.getElementById('showPoints');
        const elRandomize = document.getElementById('randomize');
        const elApply = document.getElementById('apply');

        elPoints.addEventListener('input', () => {
          settings.numPoints = parseInt(elPoints.value, 10);
          elPointsVal.textContent = String(settings.numPoints);
        });
        elCap.addEventListener('input', () => {
          settings.capacity = parseInt(elCap.value, 10);
          elCapVal.textContent = String(settings.capacity);
        });
        elSpeed.addEventListener('input', () => {
          settings.rotSpeed = parseFloat(elSpeed.value);
          elSpeedVal.textContent = settings.rotSpeed.toFixed(3);
        });
        elShowLines.addEventListener('change', () => {
          settings.showLines = elShowLines.checked;
        });
        elShowPoints.addEventListener('change', () => {
          settings.showPoints = elShowPoints.checked;
        });
        elRandomize.addEventListener('click', () => {
          randomizePoints();
          rebuildTree();
        });
        elApply.addEventListener('click', () => {
          rebuildTree();
        });
      })();
    </script>
  </body>
</html>


